//************************************************************************
//************************************************************************
//
//   File: test2.cxx 
//
//   Computes a simplified version of the 2D integral, W_lm, defined 
//   in equations (37) and (38) of the paper 
//
//      H(2s) formation in non-adiabatic ground state 
//      hydrogen atom collisions
//
//      B M McLaughlin and K L Bell
//
//      J Phys B: At Mol Phys 1985, L771-8
//
//   We set the Re[f_lm(\zeta_1) f_lm^*(\zeta_2)] to be 1.0 to avoid
//   the complicated computation needed for it. We focus here on the 
//   creation of the quadrature for the outer and inner integrals and
//   on the evaluation of the associated Legendre functions at these
//   quadrature points.
//
//   Thus for this paper we define W_{lm} to be 
//
//     W_{lm} = \int_{1}^{\infty}  
//                    {\rm d} \zeta_1 \; \exp (-R \zeta_1)    \; 
//                                        Q_{l}^{m} (\zeta_1) \;
//                     \int_{1}^{\zeta_1} {\rm d} \; \zeta_2 
//                                   \exp (-R\zeta_2) \; P_{l}^{m}  
//
//--+----1----+----2----+----3----+----4----+----5----+----6----+----7----
//
//   Version history:
//
//      Date      Modifier           Comments
//   ----------   --------   -------------------------------- 
//   7-Oct-2017   CJG        Initial version 
//  14-Oct-2017   CJG        Added loop for J terms
//   5-Jul-2017   CJG        Established as a standalone test case for 
//                           the P_lm and Q_lm template versions 
//                          
//
//   Copyright 20017,2018 (c) Charles J Gillan and B M McLaughlin 
//   All rights reserved
//
//************************************************************************
//************************************************************************

#include <iostream>
#include <iomanip>
#include <sstream>
#include <complex>
#include <cmath>
#include <chrono>

/*...............................................*/
/*                                               */
/*  Includes from the GNU Scientific Library     */
/*                                               */
/*  We use these to generate the Gauss Legendre  */
/*  quadrature for the inner integral            */
/*                                               */
/*...............................................*/

#include "gsl/gsl_sf_legendre.h"
#include "gsl/gsl_integration.h"

/*............................................*/
/*                                            */
/*  Includes from the GNU Scientific Library  */
/*                                            */
/*............................................*/

#include "associated_legendre_functions.hxx"

/**
 *   Procedure: set_gauss_lag_pts_wts()
 *
 *   Defines the Gauss-Laguerre points and weights and
 *   copies these into two vectors when the method is 
 *   called.
 *
 *   Both vectors are resized to hold precisely the points
 *   and weights.
 *
 */
void set_gauss_lag_pts_wts(std::vector<double> &pts_vec,
                           std::vector<double> &wts_vec)
  {
   //
   //---- Following generated by the tool of J S Burkhardt 
   //     at Florida State University. Available on the 
   //     web - see sub dir third-party in this source. 
   //
   //     Gauss Laguerre quadrature for 
   //
   //          \int_{0}^{\infty} e^{-x} f(x) dx
   //
   //     Cross checked usign on-line calculator at
   //
   //          http://keisan.casio.com/exec/system/1281279441
   //

   static int const NPTS = 16;

   static double const pts[NPTS] = {
                                     0.08764941047892966,
                                     0.4626963289150848,
                                     1.14105777483123,
                                     2.129283645098382,
                                     3.437086633893209,
                                     5.07801861454977,
                                     7.070338535048231,
                                     9.438314336391931,
                                    12.21422336886616,
                                    15.44152736878162,
                                    19.18015685675313,
                                    23.5159056939919,
                                    28.57872974288215,
                                    34.58339870228661,
                                    41.94045264768835,
                                    51.70116033954334
                                  };

   static double const wts[NPTS] = {
                                    0.2061517149578046,
                                    0.3310578549508826,
                                    0.2657957776442129,
                                    0.1362969342963772,
                                    0.04732892869412524,
                                    0.0112999000803394,
                                    0.00184907094352632,
                                    0.0002042719153082795,
                                    1.484458687398136e-05,
                                    6.828319330871209e-07,
                                    1.88102484107967e-08,
                                    2.86235024297389e-10,
                                    2.12707903322411e-12,
                                    6.297967002518052e-15,
                                    5.05047370003547e-18,
                                    4.161462370372835e-22,
                                   };

   //
   //---- Copy the data into the vectors
   //

   pts_vec.resize(NPTS);
   wts_vec.resize(NPTS);

   for(int ipts=0; ipts<NPTS; ++ipts)
      {
       pts_vec[ipts] = pts[ipts];
       wts_vec[ipts] = wts[ipts];
      }

   //
  
   return;
  }
   // End of set_gauss_lag_pts_wts()

/**
 *    Procedure: do_outer_integral_eqn_37()
 *
 *    Applies fixed point quadrature to integrate 
 *    the outer integral in equation 37 of the 
 *    McL+B paper. This is written as 
 *
 *      W_{lm} (R, Z, v) 
 *
 *    in the paper. This routine computes all W_{lm}
 *    for a given set of (R, Z, v) values.
 *
 *    This integral is computed for several l,m values.
 *
 *    The routine descends into a loop to evaluate 
 *    the inner integrals at each grid point of the 
 *    outer integral. 
 *
 *    NB: We assume that the points and weights have been
 *        set-up before calling this function.
 *
 *    The computed integrals are stored in 
 *
 *        W_lm_outer_integrals_mat
 *
 */
void do_outer_integral_eqn_37(std::vector<double> const &pts_outer_vec,
                              std::vector<double> const &wts_outer_vec,
                              int    const Lmax,
                              int    const Mmax,
                              double const R,
                              std::vector<std::vector<double> > &W_lm_outer_integrals_mat)
  {
   bool const zdebug = true;

   std::string const methodname_str = "do_outer_integral_eqn_37()";
 
   //

   std::ostringstream os;

   os.str(""); os.clear();

   //---------------------------------------------------
   //
   //   Debug header  
   //
   //---------------------------------------------------

   if(zdebug) 
     {
      os.str(""); os.clear();

      os << "\n\n";
      os << "     =====> " << methodname_str << " <==== ";
      os << "\n\n";
      os << "     Input data:             \n";
      os << "       Lmax = " << Lmax  << "\n";
      os << "       Mmax = " << Mmax  << "\n";
      os << "          R = " << R     << "\n";
      os << "       npts = " << pts_outer_vec.size() << "\n";
      os << "       nwts = " << wts_outer_vec.size() << "\n";
      os << "\n";
      os << "     **** End of input data ";
      os << "\n\n";

      std::cout << os.str() << "\n";
     }

   //---------------------------------------------------
   //
   //   Test input data for validity  
   //
   //---------------------------------------------------
   //
   //---- Extract the number of grid points for outer
   //     integral to a local variable
   //

   int const npts_outer = (int) pts_outer_vec.size();

   if(npts_outer <= 4)
     {
      os.str(""); os.clear();

      os << "\n\n";
      os << "     Error in: " << methodname_str << " <==== ";
      os << "\n\n";
      os << "     The number of points in the outer quadrature is too small ";
      os << "\n\n";
      os << "     Value (on input) = " << npts_outer;
      os << "\n\n";

      exit(0);
     }

   //---------------------------------------------------
   //
   //    Start timer 
   //
   //---------------------------------------------------

   auto start = std::chrono::high_resolution_clock::now();

   //---------------------------------------------------
   //
   //      Transform outer integral grid points 
   //      to [1,\infty]
   //
   //---------------------------------------------------
   //
   //---- Set the grid points for this particular R value
   //
   //     These points are assumed to be "off the cut".
   //
   //     In  compressed form, the outer integral 
   //     eqn (37) of the McL+B paper is:
   //
   //      \int_{1}^{\infty} d\zeta_1 exp(-R\zeta_1) f(\zeta_1)
   //
   //     where f() represents the expression with the 
   //     inner integral
   //
   //     Now let   
   //
   //           x = R (\zeta_1 - 1)
   //
   //     so that 
   //
   //           dx = R d(\zeta_1)
   //
   //     Outer integral in terms of \zeta_1 has limits [1,\infty]
   //
   //     When \zeta_1 = 1      then x = 0
   //     When \zeta_1 = \infty then x = \infty  
   //
   //     The outer integral, when expressed in terms of 
   //     the variable "x" becomes 
   //
   //        (exp(-R)/R)  \int_{0}^{\infty} dx exp(-x) f(x)
   //
   //     Thus the outer integral is now in the classic form 
   //     of the Gauss-Laguerre quadrature.
   //
   //        (exp(-R)/R) \sum_{1}{N} f(x_{i}) w_{i}
   //
   //     We use standard Gauss-Laguerre points and weights 
   //     but we transform back to \zeta_1 before we evaluate
   //     f() since f() is already expressed in terms of \zeta_1. 
   //

   std::vector<double> zeta_1_grid_points_vec;

   zeta_1_grid_points_vec.resize(npts_outer);
   
   for(int ipt=0; ipt<npts_outer; ++ipt)
      {
       double const x      = pts_outer_vec[ipt];

       double const temp   = x/R;

       double const zeta_1 = temp + 1.0e+00;
 
       zeta_1_grid_points_vec[ipt] = zeta_1;
      }
       // End mapping from Gauss-Lag to "zeta" 

   //

   double const transform_zeta_to_x_factor = std::exp(-R)/R;

   //
   
   if(zdebug)
     {
      os.str(""); os.clear();

      os << "\n\n";
      os << "      Grid points have been transformed from standard    \n";
      os << "      Gauss-Laguerre [0,infinity] range to [1,infinity]  \n";
      os << "      which is the range for the zeta_1 co-ordinate in   \n";
      os << "      outer integral.                                    \n";
      os << "\n";
      os << "        R = " << std::setw(10) << std::setprecision(5) << R;
      os << "\n\n";
      os << "        Transform factor zeta_1->x = " << std::setw(15) << std::setprecision(10) 
                                                    << transform_zeta_to_x_factor;
      os << "\n\n";
      os << "        Index   Gauss-Laguerre        Zeta_1               \n";
      os << "        -----   --------------   --------------            \n";

      for(int ipt=0; ipt<npts_outer; ++ipt)
         {
          os << "        " 
             << std::setw(5) << std::right    << ipt << "   "
             << std::fixed   << std::setw(14) << std::setprecision(8) << pts_outer_vec[ipt] << "   "
             << std::fixed   << std::setw(14) << std::setprecision(8) << zeta_1_grid_points_vec[ipt] 
             << "\n";
         }

      std::cout << os.str() << "\n";
     }

   //---------------------------------------------------
   //
   //     Build inner integral grid points
   //
   //---------------------------------------------------
   //
   //---- Construct Gauss-Legendre points for 
   //     an inner integral for EACH OUTER integral grid 
   //     grid point
   //
   //     NOTE: The inner integral limits are defined by
   //           the outer integral grid points. Those
   //           outer integral grid points vary with R
   //           due to the transform from [0,\infty] to 
   //           [1,\infty] for the integral limits.
   //

   std::vector<std::vector<double> > points_inner_vec;
   std::vector<std::vector<double> > weights_inner_vec;

   points_inner_vec.resize(npts_outer);
   weights_inner_vec.resize(npts_outer);

   for(int ipt_outer=0; ipt_outer<npts_outer; ++ipt_outer)
      {
       //
       //.... For this outer grid point, zeta_1, the range
       //     of the inner integral is 
       //
       //       [1,zeta_1]
       //

       double const alower = 1.0e+00;

       double const bupper = zeta_1_grid_points_vec[ipt_outer];

       double const xrange = bupper - 1.0e+00;

       //
       //.... We choose a number of points based on the
       //     size of the range. This will be the value 
       //     for the Gauss-Legendre quadrature
       //

       int npts_zeta2 = 0; 

       if(xrange < 0.5e+00)
         {
          npts_zeta2 = 2;
         }
       else if( (xrange >= 0.5e+00) && (xrange < 1.0e+00) )
         {
          npts_zeta2 = 4;
         }
       else if( (xrange >= 1.0e+00) && (xrange < 2.0e+00) )
         {
          npts_zeta2 = 8;
         }
       else if( (xrange >= 2.0e+00) && (xrange < 3.0e+00) )
         {
          npts_zeta2 = 16;
         }
       else
         {
          npts_zeta2 = 16;
         }
          // End selection of npts_zeta2 for Gauss-Legendre quadrature

       //
       //.... Extract a table of Gauss-Legendre points and weights.
       //
       //     These are in the range [-1,+1]
       //

       gsl_integration_glfixed_table *ptr_pts_wts_basic_tab = gsl_integration_glfixed_table_alloc(npts_outer);

       points_inner_vec[ipt_outer].resize(0);
       weights_inner_vec[ipt_outer].resize(0);

       //
       //.... Now transform the pts and weights to range [alower,bupper]
       //

       for(int ipt_inner=0; ipt_inner<npts_zeta2; ++ipt_inner)
          {
           double point  = 0.0e+00;
           double weight = 0.0e+00;

           int const irc = gsl_integration_glfixed_point(alower,
                                                         bupper,
                                                         ipt_inner, 
                                                         &point, 
                                                         &weight, 
                                                         ptr_pts_wts_basic_tab);

           points_inner_vec[ipt_outer].push_back(point);
           weights_inner_vec[ipt_outer].push_back(weight);
          }
           // End of loop over inner points

       gsl_integration_glfixed_table_free(ptr_pts_wts_basic_tab);

       //
       //---- Debug printout of inner quadrature for this outer grid point  
       //

       if(zdebug)
         {
          os.str(""); os.clear();

          os << "      Outer integration point #" << ipt_outer << ", zeta_1 value = " << bupper;
          os << "\n\n";
          os << "        Inner integral: #points (Gauss-Legendre) = " << npts_zeta2;
          os << "\n\n";
          os << "        Values of points (zeta_2) and weights in inner quadrature follow: ";
          os << "\n\n";
          os << "        Index       zeta_2           weight                \n";
          os << "        -----   --------------   --------------            \n";

          for(int ipt_inner=0; ipt_inner<npts_zeta2; ++ipt_inner)
             {
              os << "        " 
                 << std::setw(5) << std::right    << ipt_inner << "   "
                 << std::fixed   << std::setw(14) << std::setprecision(8) << points_inner_vec[ipt_outer][ipt_inner] << "   "
                 << std::fixed   << std::setw(14) << std::setprecision(8) << weights_inner_vec[ipt_outer][ipt_inner] 
                 << "\n";
             }

          std::cout << os.str() << "\n";
         }
          // End of debug printout 
      }
       // End of loop over outer grid to build inner integral grids

   //---------------------------------------------------
   //
   //   Prepare storage to hold Q_lm and P_lm 
   //
   //---------------------------------------------------
   //
   //---- Q_lm are generated at each outer grid point.
   //
   //     But we can allocate the storage once and forall.
   //
   //        First   dimension is L value in range [0,Lmax]
   //
   //        Second  dimension is M value in range [0,Mmax]
   //
   //     Qlm is rectangular for L,M
   //
   //     But we only use a half triangle
   //

   std::vector<std::vector<double> > qlm_mat; 

   qlm_mat.resize(Lmax+1);

   for(int ll=0; ll<=Lmax; ++ll)
      {
       qlm_mat[ll].resize(Mmax+1);
      }
      // End of loop to resize Q_{lm} storage

   //
   //---- P_{lm} functions are dependent on the inner 
   //            grid point. But again size is fixed.
   //
   //        First   dimension is L value in range [0,Lmax]
   //
   //        Second  dimension is M value in range [0,L]
   //
   //     P_{lm} is triangular for L,M
   //
   //     We use some temp storage as we generate per "M"
   //

   std::vector<std::vector<double> > plm_lower_triangular_mat; 

   plm_lower_triangular_mat.resize(Lmax+1);

   for(int ll=0; ll<=Lmax; ++ll)
      {
       plm_lower_triangular_mat[ll].resize(ll+1);

       for(int mm=0; mm<=ll; ++mm)
          {
           plm_lower_triangular_mat[ll][mm] = 0.0e+00;
          }
      }
       // End of plm_mat dimensioning

   //

   std::vector<double> plm_temp_vec(2*Lmax+1);

   //---------------------------------------------------
   //
   //    Zeroise the values of the outer integrals 
   //
   //---------------------------------------------------

   for(int ll=0; ll<W_lm_outer_integrals_mat.size(); ++ll)
      {
       for(int mm=0; mm<W_lm_outer_integrals_mat[ll].size(); ++mm)
          {
           W_lm_outer_integrals_mat[ll][mm] = 0.0e+00;
          }
      }
       // End of loop to initalise outer integral storage

   //---------------------------------------------------
   //
   //    Prepare storage area to hold the inner
   //    integrals for all (l,m) at this present 
   //    grid point
   //
   //---------------------------------------------------
   //

   std::vector<std::vector<double> > W_lm_inner_integral_mat;

   W_lm_inner_integral_mat.resize(Lmax+1);

   for(int ll=0; ll<=Lmax; ++ll)
      {
       W_lm_inner_integral_mat[ll].resize(Mmax+1);

       for(int mm=0; mm<=Mmax; ++mm)
          {
           W_lm_inner_integral_mat[ll][mm] = 0.0e+00;
          }
      }
           // End of loop to resize inner integral storage

   if(zdebug)
     {
      os.str(""); os.clear();

      os << "      All storage allocations have been performed before   \n";
      os << "      loop over quadrature points.                         \n";
      os << "\n";
      os << "      >>>>> Descending into loop over outer quadrature points \n";

      std::cout << os.str() << "\n";
     }

   //====================================================================
   //
   //   D E S C E N D   I N T O   L O O P S   F O R   I N T E G R A L S 
   //
   //====================================================================
   //
   //---- We first loop over all points in the outer
   //     quadrature
   //

   for(int ipt_outer=0; ipt_outer<npts_outer; ++ipt_outer)
      {
       //
       //.... So, we are working at point x1 of the outer integral
       //

       double const x1 = pts_outer_vec[ipt_outer];

       //
       //.... Exponential term is exp(-x1) - independent of (l,m)
       //

       double const xponential_outer = std::exp(-x1);

       if(zdebug)
         {
          os.str(""); os.clear();

          os << "      Computation of the exponential term in x1 ";
          os << "\n\n";
          os << "        x1: outer integration pt #" << ipt_outer << ", value = " << x1;
          os << "\n\n";
          os << "        exp(-x1) = " << xponential_outer;
          os << "\n\n";

          std::cout << os.str() << "\n\n";
         }

       //
       //.... Compute Q_{lm} at this grid pt, for all L,M.
       //

       unnormalised_associated_irregular_Legendre_big_arg(Lmax,
                                                          Mmax,
                                                          zeta_1_grid_points_vec[ipt_outer],
                                                          qlm_mat);

       ////////////////////////////////////////////////////
       //
       //     Inner integrals 
       //
       ////////////////////////////////////////////////////
       //
       //.... Descend into loop over inner grid points
       //
       //     Computer the inner integral for each (l,m)
       //     at when upper limit is present outer grid
       //     point.
       //

       int const npts_inner = points_inner_vec[ipt_outer].size(); 

       if(zdebug)
         {
          os.str(""); os.clear();

          os << "      >>>>> Further descent into loop over inner quadrature points         \n";
          os << "            There are " << npts_inner << " points in the inner quadrature. \n";

          std::cout << os.str() << "\n";
         }

       //
       //.... We have an accumulator for each W_{lm} 
       //
       //        W_lm_inner_integral_mat[l][m]
       //
       //     We need to zeroise the accumulators before we enter
       //     the loop over the points in the inner integrals.
       //

       for(int ll=0; ll<=Lmax; ++ll)
          {
           for(int mm=0; mm<=ll; ++mm)
              {
               W_lm_inner_integral_mat[ll][mm] = 0.0e+00;
              }
               // End of loop over mm values
          }
           // End loop over ll values 

       //

       for(int ipt_inner=0; ipt_inner<npts_inner; ++ipt_inner)
          {
           //
           //.... So, we are working at point x1/zeta_1 of the outer integral
           //                       and point zeta_2    of the inner integral
           //

           double const zeta_2 = points_inner_vec[ipt_outer][ipt_inner];

           //
           //.... Compute the exponential term, it's independent of l,m
           //

           double const temp = -R * zeta_2;

           double const xponential_inner = std::exp(temp);

           //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
           //
           //     A S S O C I A T E D   L E G E N D R E - P O L Y N O M I A L S
           //
           //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
           //
           //.... Use the recurrence relationship to build up P_lm 
           //
           //     We fix "m" and recurse up to Lmax
           //

           for(int m=0; m<=Mmax; ++m)
              {
               for(int kkkk=0; kkkk<plm_temp_vec.size(); ++kkkk)
                  {
                   plm_temp_vec[kkkk] = 0.0e+00;
                  }

               //
               //..... Compute for l=m, ...., Lmax
               //

               unnormalised_associated_regular_Legendre(Lmax,m,zeta_2,plm_temp_vec);

               //
               //..... Copy to triangle storage
               //

               for(int ll=m; ll<=Lmax; ++ll)
                  {
                   plm_lower_triangular_mat[ll][m] = plm_temp_vec[ll];
                  }
              }
               // End of loop over "m" values to build P_{lm}

           //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
           //
           //    L O O P    O V E R    L , M    V A L U E S   
           //
           //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

           for(int ll=0; ll<=Lmax; ++ll)
              {
               for(int mm=0; mm<=ll; ++mm)
                  {
                   //
                   //.... Compute the inner integrand at 
                   //     this grid point including the 
                   //     weight 
                   //
         
                   double const xintegrand =  xponential_inner * 
                                                 plm_lower_triangular_mat[ll][mm] * 
                                                    weights_inner_vec[ipt_outer][ipt_inner];

                   // 
                   //.... Add to the running sum
                   //

                   W_lm_inner_integral_mat[ll][mm] += xintegrand;
                  }
                   // End of loop over mm values
              }
               // End loop over ll values 
          }
           // End of loop over inner integral grid points

       //

       if(zdebug)
         {
          os.str(""); os.clear();

          os << "\n\n";
          os << "      Computed inner W_lm_integrals at this grid point   \n";
          os << "\n";
          os << "        Index     L       M     W_lm_integral (inner)    \n";
          os << "        -----   -----   -----   ---------------------    \n";

          int icount = 0;

          for(int ll=0; ll<=Lmax; ++ll)
             {
              for(int mm=0; mm<=ll; ++mm)
                 {
                  os << "        " 
                     << std::setw(5)    << std::right    << icount << "   "
                     << std::setw(5)    << std::right    << ll     << "   "
                     << std::setw(5)    << std::right    << mm     << "   "
                     << std::scientific << std::setw(17) << std::setprecision(8) 
                     << W_lm_inner_integral_mat[ll][mm] 
                     << "\n";

                  ++icount;
                }
                 // End loop over mm values
            }
             // End loop over ll values 

          std::cout << os.str() << "\n";
         }
          // End of debug printout of computed integrals


       ////////////////////////////////////////////////////
       //
       //    End of inner integrals 
       //
       ////////////////////////////////////////////////////
       //
       //.... The inner integrals having been computed, for all (l,m)
       //     at this point in the outer quadrature, we now add this 
       //     contibution into the running sum for each outer integral 
       //

       for(int ll=0; ll<=Lmax; ++ll)
          {
           for(int mm=0; mm<=ll; ++mm)
              {
               double xintegrand_outer;

               xintegrand_outer  = xponential_outer * qlm_mat[ll][mm] * W_lm_inner_integral_mat[ll][mm];

               xintegrand_outer *= wts_outer_vec[ipt_outer];

               W_lm_outer_integrals_mat[ll][mm] += xintegrand_outer;
              }
               // End of loop over mm values for outer integral
          }
           // End loop over ll values for outer integral 
      }
       // End of loop over outer integral grid points 

   //=====================================================
   //
   //   A S C E N D   F R O M    L O O P S 
   //
   //=====================================================   
   //
   //---- Apply the transformation factor to the outer
   //     integrals to compensate for the change of 
   //     dummy variable
   //
   //     This is a once and for all factor that sits
   //     outside each integral
   //

   for(int ll=0; ll<=Lmax; ++ll)
      {
       for(int mm=0; mm<=ll; ++mm)
          {
           W_lm_outer_integrals_mat[ll][mm] *= transform_zeta_to_x_factor;
          }
      }
       // End of loop (ll,mm) to refactor outer integals 

   //---------------------------------------------------
   //
   //   Clean the space allocated  
   //
   //---------------------------------------------------

   {
    std::vector<double> dump_vec(0);
   
    dump_vec.swap(plm_temp_vec);
   }

   //

   {
    for(int ipt_outer=0; ipt_outer<points_inner_vec.size(); ++ipt_outer)
       {
        std::vector<double> dump_vec1(0);
        std::vector<double> dump_vec2(0);

        dump_vec1.swap(points_inner_vec[ipt_outer]);
        dump_vec2.swap(weights_inner_vec[ipt_outer]);
       }

    //

    {
     std::vector<std::vector<double> > dump_vec1(0);
     std::vector<std::vector<double> > dump_vec2(0);
   
     dump_vec1.swap(points_inner_vec);
     dump_vec2.swap(weights_inner_vec);
    }
   }

   //---------------------------------------------------
   //
   //   End timer 
   //
   //---------------------------------------------------

   auto finish  = std::chrono::high_resolution_clock::now();

   auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(finish-start).count();

   if(zdebug)
     {
      os.str(""); os.clear();

      os << "\n\n";
      os << "      Elapsed time for integral computation = " << elapsed << " (nanoseconds) ";
      os << "\n";

      std::cout << os.str() << "\n";
     }

   //---------------------------------------------------
   //
   //   Output the integrals  
   //
   //---------------------------------------------------
   //
   //---- Debug printout of the W_lm integrals
   //

   if(zdebug)
     {
      os.str(""); os.clear();

      os << "\n\n";
      os << "      Computed W_lm_integrals                            \n";
      os << "\n";
      os << "        Index     L       M        W_lm_integral         \n";
      os << "        -----   -----   -----   ------------------       \n";

      int icount = 0;

      for(int ll=0; ll<=Lmax; ++ll)
         {
          for(int mm=0; mm<=ll; ++mm)
             {
              os << "        " 
                 << std::setw(5)    << std::right    << icount << "   "
                 << std::setw(5)    << std::right    << ll     << "   "
                 << std::setw(5)    << std::right    << mm     << "   "
                 << std::scientific << std::setw(17) << std::setprecision(8) << W_lm_outer_integrals_mat[ll][mm] 
                 << "\n";

              ++icount;
             }
              // End loop over mm values
         }
          // End loop over ll values 

     std::cout << os.str() << "\n";
    }
     // End of debug printout of computed integrals

   //---------------------------------------------------
   //
   //    Return point 
   //
   //---------------------------------------------------

   if(zdebug) 
     {
      os.str(""); os.clear();

      os << "\n\n";
      os << "     ***** Completed - " << methodname_str;
      os << "\n";

      std::cout << os.str() << "\n";
     }

   return;
  }
   // End of integrate_outer

/**
 *  main program 
 *
 *  Drives the evaluation of the W_lm(\rho,Z,v) 
 * 
 */
int main(int argc, char **argv)
  {
   //---------------------------------------------------
   //
   //---- Data from BMcL's thesis 
   //
   //     Geometry: page 122 defines R and theta
   //
   //               R^2 = rho^2 + z^2
   //
   //     Test data from graph on page 141
   //
   //---------------------------------------------------
   //
   ////////////////////////////////////////////////////////////////////
   //
   //      Folllowing extracted from the old Fortran code - hhg1new.for
   //                                                                      
   //....  IMPACT PARAMETER VALUES AT WHICH MATRIX ELEMENTS 
   //      ARE EVALUATED.   
   //                                                      
   //      DATA RHOVAL/0.25E0,0.5E0,0.75E0,1.0E0,1.25E0,1.5E0,1.75E0,    
   //                  2.0E0,2.25E0,2.5E0,2.75E0,3.0E0,3.25E0,3.5E0,
   //                  3.75E0,4.0E0,4.25E0,4.5E0,4.75E0,5.0E0,5.25E0,
   //                  5.5E0,5.75E0,6.0E0,6.25E0/     
   //
   //....  Z VALUES AT WHICH MATRIX ELEMENTS ARE EVALUATED.                
   //                                                                      
   //      DATA ZTVAL/0.25E0,0.5E0,0.75E0,1.0E0,1.25E0,1.5E0,1.75E0,      
   //                 2.0E0,2.25E0,2.5E0,2.75E0,3.0E0,3.25E0,3.5E0,
   //                 3.75E0,4.0E0,   
   //                 4.25E0,4.5E0,4.75E0,5.0E0,5.25E0,5.5E0,5.75E0,
   //                 6.0E0,6.25E0,     
   //                 7.25E0,8.25E0,9.25E0,10.25E0,11.25E0/             
   //  
   /////////////////////////////////////////////////////////////////////

   double z   = 0.25e+00;   

   double rho = 0.25e+00;  

   double R   = sqrt( z*z + rho*rho );

   double theta = asin( rho/R );  /* Radians */

   //

   double v   =  0.2e+00;  /* Velocity (a.u.) */
   
   //---------------------------------------------------
   //
   //   Obtain the Gauss Laguerre quadrature data 
   //
   //---------------------------------------------------
   //
   //---- The Gauss Laguerre quadrature is used for the 
   //     outer integral. 
   //
   //     We will need to transform the quadrature based
   //     on the value of "R" for each integal, but the 
   //     basic set of points and weights is unchanged.
   //
   //     Here we extract that set of points from data 
   //     tables into storage. 
   //

   std::vector<double> pts_vec;
   std::vector<double> wts_vec;

   set_gauss_lag_pts_wts(pts_vec,wts_vec);
   
   //---------------------------------------------------
   //
   //   Fixed the maximum "l" and maximum "m"
   //
   //---------------------------------------------------

   int const lmax = 12;

   int const mmax = 12;

   //---------------------------------------------------
   //
   //   Prepare storage to hold the double integrals 
   //
   //---------------------------------------------------
   //
   //---- The value of mm is always <= ll (CHECK!) 
   //

   std::vector<std::vector<double> > W_lm_outer_integrals_mat;

   //

   W_lm_outer_integrals_mat.resize(lmax+1);

   for(int ll=0; ll<=lmax; ++ll)
      {
       W_lm_outer_integrals_mat[ll].resize(ll+1);

       for(int mm=0; mm<=ll; ++mm)
          {
           W_lm_outer_integrals_mat[ll][mm] = 0.0e+00;
          }
      }
       // End of loop (ll,mm) to size outer integals storage

   //---------------------------------------------------
   //
   //    Calculate all W_lm values 
   //
   //---------------------------------------------------

   do_outer_integral_eqn_37(pts_vec, 
                            wts_vec, 
                            lmax, 
                            mmax, 
                            R, 
                            W_lm_outer_integrals_mat);

   //---------------------------------------------------
   //
   //    End of program  
   //
   //---------------------------------------------------

   return 0;
  }

//************************************************************************
//************************************************************************
//
//   End of file 
//
//************************************************************************
//************************************************************************
